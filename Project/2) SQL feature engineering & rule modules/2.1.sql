-- 2) SQL feature engineering & rule modules
-- 2.1) Design claim-level features: e.g. claim amount, units, code counts, time-of-day, duplicate indicator.
-- 1) Helper: function to count non-null across an array
CREATE OR REPLACE FUNCTION MART._NONNULL_COUNT (VARIADIC ARR TEXT[]) RETURNS INT LANGUAGE SQL IMMUTABLE AS $$
  SELECT count(*) FROM unnest(arr) AS t(x) WHERE x IS NOT NULL
$$;

-- 2) Build features from the unified fact
DROP TABLE IF EXISTS MART.CLAIM_FEATURES CASCADE;

CREATE TABLE MART.CLAIM_FEATURES AS
WITH
	BASE AS (
		SELECT
			F.CLAIMID,
			F.CLAIM_TYPE,
			F.PROVIDER,
			F.BENEID,
			F.CLAIM_START,
			F.CLAIM_END,
			F.REIMB_AMT,
			F.DEDUCTIBLE_PAID,
			F.ADMIT_DT,
			F.DISCHARGE_DT,
			F.ADMIT_DX,
			F.DRG,
			-- counts
			MART._NONNULL_COUNT (
				F.DX1,
				F.DX2,
				F.DX3,
				F.DX4,
				F.DX5,
				F.DX6,
				F.DX7,
				F.DX8,
				F.DX9,
				F.DX10
			) AS DX_COUNT,
			MART._NONNULL_COUNT (F.PX1, F.PX2, F.PX3, F.PX4, F.PX5, F.PX6) AS PX_COUNT,
			-- simple ICD prefix (first char) for dx1
			CASE
				WHEN F.DX1 IS NOT NULL THEN SUBSTR(F.DX1, 1, 1)
			END AS PRIMARY_DX_PREFIX
		FROM
			MART.FACT_CLAIM F
	),
	CAL AS (
		SELECT
			*,
			EXTRACT(
				DOW
				FROM
					CLAIM_START
			)::INT AS DOW,
			(
				EXTRACT(
					DOW
					FROM
						CLAIM_START
				)::INT IN (0, 6)
			)::BOOLEAN AS IS_WEEKEND,
			EXTRACT(
				MONTH
				FROM
					CLAIM_START
			)::INT AS MONTH,
			EXTRACT(
				QUARTER
				FROM
					CLAIM_START
			)::INT AS QUARTER
		FROM
			BASE
	),
	LOS AS (
		SELECT
			*,
			CASE
				WHEN CLAIM_TYPE = 'IP'
				AND ADMIT_DT IS NOT NULL
				AND DISCHARGE_DT IS NOT NULL THEN GREATEST((DISCHARGE_DT - ADMIT_DT), 0)
				ELSE NULL::INT
			END AS LOS_DAYS,
			CASE
				WHEN CLAIM_TYPE = 'IP'
				AND ADMIT_DT IS NOT NULL
				AND DISCHARGE_DT IS NOT NULL
				AND GREATEST((DISCHARGE_DT - ADMIT_DT), 0) < 2 THEN 1
				ELSE 0
			END AS SHORT_STAY_FLAG
		FROM
			CAL
	),
	AMOUNT_FLAGS AS (
		SELECT
			*,
			(REIMB_AMT = 0)::INT AS AMOUNT_ZERO_FLAG,
			(REIMB_AMT > 75000)::INT AS AMOUNT_HIGH_FLAG -- tune later using your p99/p999
		FROM
			LOS
	),
	-- Exact duplicate: same bene+provider+claim_start and same reimb_amt
	EXACT_DUPS AS (
		SELECT
			CLAIMID,
			CASE
				WHEN COUNT(*) OVER (
					PARTITION BY
						BENEID,
						PROVIDER,
						CLAIM_START,
						REIMB_AMT
				) > 1 THEN 1
				ELSE 0
			END AS EXACT_DUPLICATE_FLAG
		FROM
			MART.FACT_CLAIM
	),
	-- Near-duplicate: Â±1 day window with approx amount (within 1%) for same bene+provider
	NEAR_DUPS AS (
		SELECT
			F.CLAIMID,
			COUNT(*) FILTER (
				WHERE
					F2.CLAIMID <> F.CLAIMID
			) AS NEAR_DUPLICATE_GROUP_SIZE
		FROM
			MART.FACT_CLAIM F
			JOIN MART.FACT_CLAIM F2 ON F2.BENEID = F.BENEID
			AND F2.PROVIDER = F.PROVIDER
			AND F2.CLAIM_START BETWEEN F.CLAIM_START - INTERVAL '1 day' AND F.CLAIM_START  + INTERVAL '1 day'
			AND F2.REIMB_AMT IS NOT NULL
			AND F.REIMB_AMT IS NOT NULL
			AND ABS(F2.REIMB_AMT - F.REIMB_AMT) <= 0.01 * GREATEST(F2.REIMB_AMT, F.REIMB_AMT)
		GROUP BY
			F.CLAIMID
	)
SELECT
	A.CLAIMID,
	A.CLAIM_TYPE,
	A.PROVIDER,
	A.BENEID,
	A.CLAIM_START,
	A.CLAIM_END,
	A.REIMB_AMT,
	A.DEDUCTIBLE_PAID,
	A.DX_COUNT,
	A.PX_COUNT,
	A.PRIMARY_DX_PREFIX,
	A.DRG,
	A.DOW,
	A.IS_WEEKEND,
	A.MONTH,
	A.QUARTER,
	A.LOS_DAYS,
	A.SHORT_STAY_FLAG,
	A.AMOUNT_ZERO_FLAG,
	A.AMOUNT_HIGH_FLAG,
	COALESCE(ED.EXACT_DUPLICATE_FLAG, 0) AS EXACT_DUPLICATE_FLAG,
	COALESCE(ND.NEAR_DUPLICATE_GROUP_SIZE, 0) AS NEAR_DUPLICATE_GROUP_SIZE
FROM
	AMOUNT_FLAGS A
	LEFT JOIN EXACT_DUPS ED USING (CLAIMID)
	LEFT JOIN NEAR_DUPS ND USING (CLAIMID);

CREATE INDEX IF NOT EXISTS CF_PROVIDER_IDX ON MART.CLAIM_FEATURES (PROVIDER);

CREATE INDEX IF NOT EXISTS CF_BENEID_IDX ON MART.CLAIM_FEATURES (BENEID);

CREATE INDEX IF NOT EXISTS CF_START_IDX ON MART.CLAIM_FEATURES (CLAIM_START);